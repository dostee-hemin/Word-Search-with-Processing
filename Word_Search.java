/* autogenerated by Processing revision 1293 on 2024-10-07 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Word_Search extends PApplet {



int boardSize = 12;
float tileSize;

int endTextAlpha = 0;
boolean showEndText;
PImage endText;

Board board;

boolean isDragging;
PVector startTile;

int[] wordColors = {color(255, 247, 0), // Yellow
  color(73, 107, 240), // Dark Blue
  color(0, 219, 49), // Green
  color(252, 87, 46), // Red
  color(204, 46, 252), // Purple
  color(2, 213, 234), // Light Blue
  color(250, 121, 237), // Pink
  color(252, 140, 3), // Orange
  color(255, 77, 181), // Magenta
  color(176, 255, 93), // Lime
  color(118, 176, 255), // Ocean Blue
  color(255, 233, 118) // Light Orange
};
int currentColor = 0;
ArrayList<String> chosenWords = new ArrayList<String>();
ArrayList<String> wordsFound = new ArrayList<String>();
String catagory = "";
String selectedWord;

public void setup() {
  /* size commented out by preprocessor */;
  
  LoadWords();
  LoadSounds();

  tileSize = (width-300)/boardSize;
  board = new Board(boardSize, boardSize);
  endText = loadImage("Level Complete.png");
  endText.resize(500, 200);

  board.generateNewBoard();

  textFont(createFont("BalooChettan2-Bold.ttf", 100));
}

public void draw() {
  background(20, 40, 57);

  board.display();
  
  fill(255);
  textSize(30);
  textAlign(CORNER);
  text("Catagory: " + catagory, 15, 40);
  textAlign(CENTER);
  text("Press 'r'", 70, 300);
  text("to Reset", 70, 330);

  if (isDragging) {
    board.generateLine();

    if (!selectedWord.equals("")) {
      // Band surrounding text
      strokeWeight(36);
      stroke(wordColors[currentColor]);
      line(width/2 - selectedWord.length()*9, 40, width/2 + selectedWord.length()*9, 40);

      // Highlighted text
      fill(0);
      textSize(30);
      textAlign(CENTER);
      text(selectedWord, width/2, 50);
    }
  }


  // Display all the words in this round

  // The box containing the words
  fill(0xFF034D89, 100);
  stroke(0xFF196DAF);
  strokeWeight(10);
  rect(width/2, height-120, width-180, 170, 7);

  // The words
  for (float i=0; i<chosenWords.size(); i++) {
    String s = chosenWords.get(PApplet.parseInt(i));
    float x = 200 + floor(i/4) * 200;
    float y = height-170 + i%4 * 40;
    fill(255);
    if (wordsFound.contains(s)) {
      fill(wordColors[wordsFound.indexOf(s)], 125);
    }
    textSize(25);
    textAlign(CENTER);
    text(s, x, y);
  }

  board.update();

  if (wordsFound.size() == 12) {
    if (frameCount % 50 == 0) {
      showEndText = true;
    }

    if (showEndText) {
      imageMode(CENTER);
      tint(0, endTextAlpha/2);
      image(endText, width/2, height/2 - (endTextAlpha/2) + 10);
      tint(255, endTextAlpha);
      image(endText, width/2, height/2 - (endTextAlpha/2));

      if (endTextAlpha < 255) {
        endTextAlpha += 7;
      }
    }
  }
}
class Board {
  int columns;
  int rows;

  int pulseI;

  Tile[][] tiles;
  ArrayList<WordLine> wordLines = new ArrayList<WordLine>();
  PVector previousMouseTile;

  Board(int columns, int rows) {
    this.columns = columns;
    this.rows = rows;

    tiles = new Tile[columns][rows];
    for (int i=0; i<columns; i++) {
      for (int j=0; j<rows; j++) {
        float x = 150 + tileSize/2 + i*tileSize;
        float y = 75 + tileSize/2 + j*tileSize;
        tiles[i][j] = new Tile(x, y);
      }
    }

    previousMouseTile = new PVector(-1, -1);
  }

  public void generateNewBoard() {
    for (String s : chosenWords) {
      addWord(s);
    }
    fillUp();
  }

  public void update() {
    for (int i=0; i<columns; i++) {
      for (int j=0; j<rows; j++) {          
        tiles[i][j].update();
      }
    }

    if (pulseI < columns+rows) {
      if (pulseI == 0) {
        swooshSound.play();
      }
      int j=0;
      for (int i=pulseI; i>=0; i--) {
        if (i < columns && j < rows) {
          tiles[i][j].isPulsing = true;
        }
        j++;
      }
      pulseI++;
    }
  }

  public void showFound() {
    for (int i=0; i<columns; i++) {
      for (int j=0; j<rows; j++) {
        if (tiles[i][j].isSelected) {
          tiles[i][j].isPulsing = true;
        }
      }
    }
  }

  public void display() {
    noStroke();
    fill(255);
    rectMode(CENTER);
    rect(width/2, 75 +(boardSize/2)*tileSize, width-300, width-300, 7);

    // Display all the lines drawn
    for (WordLine w : wordLines) {
      w.display();
    }
    // Display all the tiles
    for (int i=0; i<columns; i++) {
      for (int j=0; j<rows; j++) {
        tiles[i][j].display();
      }
    }    
    // Shine the tile the mouse is currently on
    if (mouseIsInBoard()) {
      int i = round((mouseX-(150 + tileSize/2))/tileSize);
      int j = round((mouseY-(75 + tileSize/2))/tileSize);
      tiles[i][j].shine();
    }
  }

  public void addWord(String newWord) {
    // Pick a direction that the word will be written in
    PVector direction = new PVector(round(random(-1.5f, 1.5f)), round(random(-1.5f, 1.5f)));
    if (direction.mag() == 0) {
      direction.x = 1;
    }

    // The current tile that the printer is on
    // (currently hasn't found a starting position)
    PVector currentTile = new PVector(-1, -1);

    // While the new word can not be placed on the board
    int counter = 0;
    boolean canBePlaced = false;
    while (!canBePlaced) {
      // Pick a new starting location
      currentTile = pickStart(direction, newWord.length());

      // Move in that direction checking letter by letter
      // if it can be placed on the board
      for (int currentChar=0; currentChar<newWord.length(); currentChar++) {
        PVector index = PVector.add(currentTile, PVector.mult(direction, currentChar));
        Tile t = tiles[PApplet.parseInt(index.x)][PApplet.parseInt(index.y)];
        if (!t.isEmpty() && t.letter != newWord.charAt(currentChar)) {
          canBePlaced = false;
          break;
        }
        canBePlaced = true;
      }


      // Increase the counter after every try.
      // If there is a stack overflow,
      // pick a new direction and try again
      counter++;
      if (counter > 500) {
        counter = 0;

        direction = new PVector(round(random(-1.5f, 1.5f)), round(random(-1.5f, 1.5f)));
        if (direction.mag() == 0) {
          direction.x = 1;
        }
      }
    }

    // By this point, we know that the word can be placed in a specific way,
    // so now we place the tile
    for (int currentChar=0; currentChar<newWord.length(); currentChar++) {
      Tile t = tiles[PApplet.parseInt(currentTile.x)][PApplet.parseInt(currentTile.y)];
      t.letter = newWord.charAt(currentChar);
      currentTile.add(direction);
    }
  }

  public PVector pickStart(PVector direction, int wordLength) {
    int startI = -1;
    int startJ = -1;

    switch(floor(direction.x)) {
    case -1:
      startI = floor(random(wordLength-1, columns));
      break;
    case 0:
      startI = floor(random(columns));
      break;
    case 1:
      startI = floor(random(columns-wordLength));
      break;
    }

    switch(floor(direction.y)) {
    case -1:
      startJ = floor(random(wordLength-1, rows));
      break;
    case 0:
      startJ = floor(random(rows));
      break;
    case 1:
      startJ = floor(random(rows-wordLength));
      break;
    }

    return new PVector(startI, startJ);
  }

  public void fillUp() {
    char[] letters = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
    for (int i=0; i<columns; i++) {
      for (int j=0; j<rows; j++) {
        if (tiles[i][j].letter == ' ') {
          tiles[i][j].letter = letters[floor(random(letters.length))];
        }
      }
    }
  }

  public void startWordLine() {
    if (board.mouseIsInBoard()) {
      selectSound.play();
      int i = round((mouseX-(150 + tileSize/2))/tileSize);
      int j = round((mouseY-(75 + tileSize/2))/tileSize);
      startTile = new PVector(i, j);
      wordLines.add(new WordLine(tiles[i][j].location.copy(), wordColors[currentColor]));
    }
  }

  public boolean mouseIsInBoard() {
    return mouseX > 150 && mouseX < 150 + tileSize*boardSize && 
      mouseY > 75 && mouseY < 75 + tileSize*boardSize;
  }

  public void generateLine() {
    int i = round((mouseX-(150 + tileSize/2))/tileSize);
    int j = round((mouseY-(75 + tileSize/2))/tileSize);
    PVector mouseTile = new PVector(i, j);

    // Check to see if the mouse didn't start from outside the board and move in
    if (wordLines.isEmpty()) {
      selectedWord = "";
      return;
    }

    // If the player hasn't moved the mouse, 
    // there is no need to calculate a new line so leave the function
    if (previousMouseTile.x == mouseTile.x && previousMouseTile.y == mouseTile.y) {
      return;
    }
    moveSound.play();

    selectedWord = "";
    deselectAllTiles();

    PVector startToMouse = PVector.sub(mouseTile, startTile).normalize();
    PVector direction = startToMouse.copy();
    direction.x = round(direction.x);
    direction.y = round(direction.y);

    PVector current = startTile.copy();
    if (startToMouse.heading() % HALF_PI == 0) {
      while (!(current.x == mouseTile.x && current.y == mouseTile.y)) {
        tiles[PApplet.parseInt(current.x)][PApplet.parseInt(current.y)].isSelected = true;
        selectedWord += tiles[PApplet.parseInt(current.x)][PApplet.parseInt(current.y)].letter;
        current.add(direction);
      }
    } else {
      while (current.x != mouseTile.x && current.y != mouseTile.y) {
        tiles[PApplet.parseInt(current.x)][PApplet.parseInt(current.y)].isSelected = true;
        selectedWord += tiles[PApplet.parseInt(current.x)][PApplet.parseInt(current.y)].letter;
        current.add(direction);
      }
    }
    tiles[PApplet.parseInt(current.x)][PApplet.parseInt(current.y)].isSelected = true;
    selectedWord += tiles[PApplet.parseInt(current.x)][PApplet.parseInt(current.y)].letter;

    WordLine currentLine = wordLines.get(wordLines.size()-1);
    currentLine.setEndPoint(current.mult(tileSize).add(150 + tileSize/2, 75 + tileSize/2));

    previousMouseTile = mouseTile;
  }

  public void deselectAllTiles() {
    for (int i=0; i<columns; i++) {
      for (int j=0; j<rows; j++) {
        tiles[i][j].isSelected = false;
      }
    }
  }
}
public void LoadWords() {
  // Clear out everything to start fresh
  chosenWords.clear();
  catagory = "";
  
  // Load the text file into an array (each element is a catagory)
  String[] txt = loadStrings("Dictionary.txt");
  
  // Pick a random catagory and get the line of that catagory
  int catagoryIndex = floor(random(txt.length));
  String chosenLine = txt[catagoryIndex];
  
  // Read the first word up unitl the '-' (this is the catagory name)
  int currentI = 0;
  while (chosenLine.charAt(currentI) != '-') {
    catagory += chosenLine.charAt(currentI);
    currentI++;
  }
  
  // Store all possible words in this catagory into an array
  String[] allWords = chosenLine.substring(currentI+1, chosenLine.length()).split(" ");
  
  // While I haven't gotten all the words I need...
  while (chosenWords.size() != 12) {
    // Pick a random word (make it upper case)
    int index = floor(random(allWords.length));
    String currentWord = allWords[index].toUpperCase();
    
    // If the word is not too long and is not already chosen, add it to the list
    if (!chosenWords.contains(currentWord) && currentWord.length() <= boardSize) {
      chosenWords.add(currentWord);
    }
  }
  
  // Sort all the chosen words in order of decreasing size
  // (this improves the generation by placing the biggest words first)
  quickSort(0, chosenWords.size()-1);
}


/*    Simple Quick Sort Algorithm    */
public void quickSort(int start, int end) {
  if(start >= end) {
    return;
  }
  
  int partitionIndex = partition(start, end);
  
  quickSort(start, partitionIndex-1);
  quickSort(partitionIndex+1, end);
}

public int partition(int start, int end) {
  int partitionIndex = start;
  int partitionValue = chosenWords.get(end).length();
  for(int i=start; i<end; i++) {
    if(chosenWords.get(i).length() > partitionValue) {
      swap(partitionIndex, i);
      partitionIndex++;
    }
  }
  swap(partitionIndex, end);
  return partitionIndex;
}

public void swap(int a, int b) {
  String temp = chosenWords.get(a);
  chosenWords.set(a,chosenWords.get(b));
  chosenWords.set(b,temp);
}
SoundFile swooshSound;
SoundFile selectSound;
SoundFile deselectSound;
SoundFile moveSound;
SoundFile foundSound;

public void LoadSounds() {
  swooshSound = new SoundFile(this, "Swoosh.mp3");
  selectSound = new SoundFile(this, "Select.mp3");
  deselectSound = new SoundFile(this, "Deselect.mp3");
  moveSound = new SoundFile(this, "Move.mp3");
  foundSound = new SoundFile(this, "Found.mp3");
}
class Tile {
  PVector location;
  char letter = ' ';

  boolean isSelected;

  float normalSize;
  float currentSize;
  float largeSize;
  boolean isPulsing;
  boolean isRising = true;

  Tile(float x, float y) {
    location = new PVector(x, y);
    normalSize = tileSize*0.8f;
    largeSize = tileSize*1.3f;
    currentSize = normalSize;
  }

  public void display() {
    if (!isEmpty()) {
      fill(0);
      textSize(currentSize);
      textAlign(CENTER);
      text(letter, location.x, location.y + tileSize/5);
    }
  }

  public void update() {
    if (isPulsing) {
      if (isRising) {
        currentSize = lerp(currentSize, largeSize, 0.2f);
        if (currentSize > largeSize-2) {
          isRising = false;
        }
      } else {
        currentSize = lerp(currentSize, normalSize, 0.2f);
        if (currentSize < normalSize+2) {
          isRising = true;
          isPulsing = false;
        }
      }
    }
  }

  public void shine() {
    strokeWeight(3);
    stroke(0xFF0582FC, 50);
    fill(0xFF4CB7FC, 50);
    ellipse(location.x, location.y, tileSize, tileSize);
  }

  public boolean isEmpty() {
    return letter == ' ';
  }

  public boolean isUnderMouse() {
    return mouseX > location.x - tileSize/2 &&
      mouseX < location.x + tileSize/2 &&
      mouseY > location.y - tileSize/2 &&
      mouseY < location.y + tileSize/2;
  }
}
public void keyPressed() {
  if (key == 'r') {
    // Reset
    LoadWords();
    
    // Generate a new board
    board = new Board(boardSize, boardSize);
    board.generateNewBoard();

    // Reset all variables
    wordsFound.clear();
    currentColor = 0;
    showEndText = false;
    endTextAlpha = 0;
  }
}

public void mousePressed() {
  // Start drawing the word line
  board.startWordLine();
}
public void mouseDragged() {
  // Start generating the word line if the mouse is in the board
  isDragging = board.mouseIsInBoard();
}

public void mouseReleased() {
  // If the word selected is a correct word and hasn't already been found...
  if (chosenWords.contains(selectedWord) && !wordsFound.contains(selectedWord)) {
    // Add it to the wordsFound list
    wordsFound.add(selectedWord);

    // Change the current color of highlight
    if (currentColor < wordColors.length-1) {
      currentColor++;
    }
    
    // Pulse the letters that have just been found and play the sound effect
    board.showFound();
    foundSound.play();
  } 
  
  // If the selected word is wrong
  else {
    if (!board.wordLines.isEmpty()) {
      // Remove the highlight and play the deselect sound effect
      board.wordLines.remove(board.wordLines.size()-1);
      deselectSound.play();
    }
  }
  
  isDragging = false;
  board.deselectAllTiles();
}
class WordLine {
  PVector startPoint;
  PVector endPoint;
  
  int c;
  
  WordLine(PVector startPoint, int c) {
    this.startPoint = startPoint;
    endPoint = startPoint;
    
    this.c = c;
  }
  
  public void setEndPoint(PVector endPoint) {
    this.endPoint = endPoint;
  }
  
  public void display() {
    stroke(c, 175);
    strokeWeight(tileSize*0.9f);
    line(startPoint.x,startPoint.y,endPoint.x,endPoint.y);
  }
}


  public void settings() { size(800, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Word_Search" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
